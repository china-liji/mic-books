(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{208:function(n,e,t){"use strict";t.d(e,"a",(function(){return u}));var u=function(n,e,t){if(this.name=n,this.source=e,!t){var u=/\.([^/\\.]+?)(?=(?:[?#].*)?$)/.exec(this.name);t=u?u[1]:""}this.type=t}},213:function(n,e,t){"use strict";e.a="import { useRef } from 'react';\n\nexport default (value) => {\n  const ref = useRef(value);\n  // 进行对比，记录对比结果\n  const result = ref.current !== value;\n\n  // 记录当前值\n  ref.current = value;\n  // 返回对比结果\n  return result;\n};"},214:function(n,e,t){"use strict";t.d(e,"a",(function(){return s})),t.d(e,"b",(function(){return a}));var u=t(208),r=t(213),s=new u.a("use-has-changed.js",r.a),a=new u.a("use-update-times.js","import { useRef, useEffect } from 'react';\n\nexport default () => {\n  const ref = useRef(1);\n\n  /**\n   * 不能直接使用 return ++ref.current，\n   * 因为在某些情况下，进了渲染函数，不代表组件会被更新，比如：\n   * const [num, setNum] = useState(0);\n   * ...\n   * setNum(1); setNum(2); setNum(0);\n   * 连续的 setNum，最后 num 还是等于 0，并未变化，\n   * 这会导致进入组件的渲染函数，但其实组件不会被更新。\n   * 所以，利用 useEffect 才能表明组件是否被更新。\n   */\n  useEffect(() => {\n    ref.current++;\n  }, [Math.random()]);\n  \n  return ref.current;\n};")},354:function(n,e,t){"use strict";t.r(e),t.d(e,"interfaceDemo",(function(){return a})),t.d(e,"useHasChangedDemo",(function(){return f}));var u=t(98),r=t(214),s=t(208),a=new u.a([new s.a("JavaScript","/**\n * useRef 返回一个可变引用对象。\n * @param {unknown} initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n * @returns {React.MutableRefObject} 可变引用对象\n */\nfunction useRef(initialValue = undefined) {}","js"),new s.a("TypeScript","interface useRef {\n  /**\n   * useRef 返回一个可变引用对象。\n   * @param initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n   * @returns 可变引用对象。\n   */\n  <T>(initialValue: T): React.MutableRefObject<T>;\n\n  /**\n   * useRef 返回一个可变引用对象（重载 - 返回 RefObject 形式，一般适用于 ref 属性，需启用 tsconfig 的 strictNullChecks 选项）。\n   * @param initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n   * @returns 可变引用对象。\n   */\n  <T>(initialValue: T | null): React.RefObject<T>;\n\n  /**\n   * useRef 返回一个可变引用对象（重载 - 无参数形式）。\n   * @returns 可变引用对象。\n   */\n  <T = undefined>(): React.MutableRefObject<T | undefined>;\n}","ts")]),f=new u.a([r.a]);e.default="### 描述\n`useRef` 返回一个可变引用对象，其 `.current` 属性初始化为传递的参数 - `initialValue`。返回的对象将被记忆化，在组件的整个生命周期内保持不变。值得注意的是，`useRef()` 不仅对 `ref` 属性有用，还能很方便地将任何可变值保持在对应引用的位置。\n\n### 文档释义\n```demo\nimport(interfaceDemo);\n```\n\n### 基础调用\n```jsx\nconst numRef = useRef(1);\nnumRef.current++;\n\nconst strRef = useRef('abc');\nstrRef.current += 'd';\n\nconst arrRef = useRef([]);\narrRef.current.push('你好，中国');\n\nconst divRef = useRef(null);\n<div ref={divRef} />;\n\nconst buttonRef = useRef();\n<button ref={buttonRef} />;\n```\n\n### 示例\n该 `useRef` 实例是我们文档中较多引用到的自编 `hooks` 之一 - `useHasChanged`，用于判断某个值是否有变化。\n```demo\nimport(useHasChangedDemo);\n```"}}]);