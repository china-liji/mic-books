(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{195:function(n,e,t){"use strict";t.d(e,"a",(function(){return u}));var u=function(){function n(n,e){this.name=n,this.source=e}return Object.defineProperty(n.prototype,"type",{get:function(){var n=/\.([^/\\.]+?)(?=(?:[?#].*)?$)/.exec(this.name);return n?n[1]:""},enumerable:!1,configurable:!0}),n}()},198:function(n,e,t){"use strict";e.a="import { useRef } from 'react';\n\nexport default (value: unknown): boolean => {\n  const ref = useRef(value);\n  // 进行对比，记录对比结果\n  const result = ref.current !== value;\n\n  // 记录当前值\n  ref.current = value;\n  // 返回对比结果\n  return result;\n};"},199:function(n,e,t){"use strict";t.d(e,"a",(function(){return s})),t.d(e,"b",(function(){return f}));var u=t(195),r=t(198),s=new u.a("use-has-changed.ts",r.a),f=new u.a("use-update-times.ts","import { useRef, useEffect } from 'react';\n\nexport default (): number => {\n  const ref = useRef(1);\n\n  /**\n   * 不能直接使用 return ++ref.current，\n   * 因为在某些情况下，进了渲染函数，不代表组件会被更新，比如：\n   * const [num, setNum] = useState(0);\n   * ...\n   * setNum(1); setNum(2); setNum(0);\n   * 连续的 setNum，最后 num 还是等于 0，并未变化，\n   * 这会导致进入组件的渲染函数，但其实组件不会被更新。\n   * 所以，利用 useEffect 才能表明组件是否被更新。\n   */\n  useEffect((): void => {\n    ref.current++;\n  }, [Math.random()]);\n  \n  return ref.current;\n};")},497:function(n,e,t){"use strict";t.r(e),t.d(e,"useHasChangedDemo",(function(){return s}));var u=t(93),r=t(199),s=new u.a([r.a]);e.default="### 描述\n`useRef` 返回一个可变引用对象，其 `.current` 属性初始化为传递的参数 - `initialValue`。返回的对象将被记忆化，在组件的整个生命周期内保持不变。值得注意的是，`useRef()` 不仅对 `ref` 属性有用，还能很方便地将任何可变值保持在对应引用的位置。\n\n### TsDoc 释义\n```ts\n/**\n * useRef 返回一个可变引用对象。\n * @param initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n * @version 16.8.0\n */\nfunction useRef<T>(initialValue: T): MutableRefObject<T>;\n/**\n * useRef 返回一个可变引用对象（重载 - 返回 RefObject 形式，一般适用于 ref 属性，需启用 tsconfig 的 strictNullChecks 选项）。\n * @param initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n * @version 16.8.0\n */\nfunction useRef<T>(initialValue: T | null): RefObject<T>;\n/**\n * useRef 返回一个可变引用对象（重载 - 无参数形式）。\n * @version 16.8.0\n */\nfunction useRef<T = undefined>(): MutableRefObject<T | undefined>;\n```\n\n### 基础调用\n```tsx\nconst numRef = useRef(1);\nnumRef.current++;\n\nconst strRef = useRef('abc');\nstrRef.current += 'd';\n\nconst arrRef = useRef<string[]>([]);\narrRef.current.push('你好，中国');\n\nconst divRef = useRef<HTMLDivElement>(null);\n<div ref={divRef} />;\n\nconst buttonRef = useRef<HTMLButtonElement>();\n<button ref={buttonRef as React.RefObject<HTMLButtonElement>} />;\n```\n\n### 示例\n该 `useRef` 实例是我们文档中较多引用到的自编 `hooks` 之一 - `useHasChanged`，用于判断某个值是否有变化。\n```demo\nimport(useHasChangedDemo);\n```"}}]);