(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{174:function(n,e,t){"use strict";t.d(e,"a",(function(){return s})),t.d(e,"b",(function(){return c}));var r=t(0),o=t.n(r),a=t(172),s=function(n,e,t,r){void 0===e&&(e=!1),void 0===t&&(t=window);for(var o=[],a=0,s=Object.getOwnPropertyNames(t).sort();a<s.length;a++){var c=s[a],E=t[c],i=(E||{}).prototype;switch(!0){case"function"!=typeof E:case!i:case!(i instanceof n):continue}(Object.getPrototypeOf(i)===n.prototype?!e:e)&&(o.push(i),r&&r(c,i))}return o},c=function(n,e,t){void 0===e&&(e=!1);var r=[];return s(n,e,t,(function(n,e){r.push(o.a.createElement(a.Inspector,{key:n,name:n,value:e}))})),r}},419:function(n,e,t){"use strict";t.r(e),t.d(e,"watcherDemo",(function(){return u})),t.d(e,"typesDemo",(function(){return T}));var r=t(0),o=t.n(r),a=t(176),s=t(174),c=t(172),E=function(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var r=Array(n),o=0;for(e=0;e<t;e++)for(var a=arguments[e],s=0,c=a.length;s<c;s++,o++)r[o]=a[s];return r};var i=t(74),u=new i.a([],(function(){return o.a.createElement("div",null,o.a.createElement(c.Inspector,{name:"Rexjs.Expression",value:a.a.Expression.prototype}))})),T=new i.a([],(function(){return o.a.createElement("div",null,o.a.createElement(c.Inspector,{name:"all",value:E(Object(s.a)(a.a.Expression,!1,a.a),Object(s.a)(a.a.Expression,!0,a.a))}))}),!1,!0);e.default="### 描述\n`Expression` - `表达式`，是由数字、变量、运算符等以能求得结果的组合。一个表达式，可能包含一个或多个子表达式，它是语句与语法内容（`语法标签`）的沟通桥梁。。\n\n### 观察\n```inline-demo\nimport(watcherDemo);\n```\n\n### 静态属性\n* `STATE_NONE`: *number* - 无状态。\n* `STATE_EXPRESSION_END`: *number* - 表达式结束状态，表示当前表达式是一个独立完整的表达式。\n* `STATE_STATEMENT_ENDABLE`: *number* - 语句可结束状态，“继承”至 `STATE_EXPRESSION_END`。表示当前语句已经是一个完整语句，就算没有明确的语句分隔符（如分号），后面也可以接其他语句。一般由换行符进行设定，出现该状态的情况下，理应满足 `ASI机制`。\n* `STATE_STATEMENT_END`: *number* - 语句结束状态，“继承”至 `STATE_STATEMENT_ENDABLE`。表示当前语句已经是一个完整语句，就算不换行，后面也可以接其他语句，一般由分号进行设定。当开始编译，进行语句连接时，应该在两语句之间加语句连接符，如分号等。\n* `STATE_STATEMENT_ENDED`: *number* - 语句已结束状态，“继承”至 `STATE_STATEMENT_END`。表示当前语句已经是一个完整语句，就算不换行，后面也可以接其他语句（如：`class A {} 123`），一般直接在表达式的属性中以只读形式设置。当开始编译，进行语句连接时，不需要再加语句连接符，如分号等。\n\n### 属性\n* `context`: *Rexjs.Context* - 标签在语法文件中所匹配的上下文。\n* `default`: *boolean* · *readOnly* - 获取是否为默认表达式。\n* `empty`: *boolean*· *readOnly* - 获取是否为空表达式。\n* `state`: *number* - 表达式状态。\n\n### 方法\n* `compileTo()`: *void* - 提取并编译表达式文本内容，即需要将高版本语法转换为低版本语法，一般编译条件由其他表达式的 `extractTo` 或 `compileTo` 方法内部确定，并且需要主动调用。\n* `extractTo`: *void* - 提取表达式文本内容，此方法也可以编译表达式，但一般编译条件是由该方法内部确定，是默认的、自动的提取方式。\n\n### Rexjs 中的表达式\n```inline-demo\nimport(typesDemo);\n```\n\n### 更多内容\n* [Statements](#/rexjs/statements)\n* [Statement](#/rexjs/statement)\n* [SyntaxTag](#/rexjs/syntax-tag)"}}]);