(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{195:function(n,e,t){"use strict";t.d(e,"a",(function(){return u}));var u=function(){function n(n,e){this.name=n,this.source=e}return Object.defineProperty(n.prototype,"type",{get:function(){var n=/\.([^/\\.]+?)(?=(?:[?#].*)?$)/.exec(this.name);return n?n[1]:""},enumerable:!1,configurable:!0}),n}()},198:function(n,e,t){"use strict";e.a="import { useRef } from 'react';\n\nexport default (value: unknown): boolean => {\n  const ref = useRef(value);\n  // 进行对比，记录对比结果\n  const result = ref.current !== value;\n\n  // 记录当前值\n  ref.current = value;\n  // 返回对比结果\n  return result;\n};"},199:function(n,e,t){"use strict";t.d(e,"a",(function(){return o})),t.d(e,"b",(function(){return r}));var u=t(195),a=t(198),o=new u.a("use-has-changed.ts",a.a),r=new u.a("use-update-times.ts","import { useRef, useEffect } from 'react';\n\nexport default (): number => {\n  const ref = useRef(1);\n\n  /**\n   * 不能直接使用 return ++ref.current，\n   * 因为在某些情况下，进了渲染函数，不代表组件会被更新，比如：\n   * const [num, setNum] = useState(0);\n   * ...\n   * setNum(1); setNum(2); setNum(0);\n   * 连续的 setNum，最后 num 还是等于 0，并未变化，\n   * 这会导致进入组件的渲染函数，但其实组件不会被更新。\n   * 所以，利用 useEffect 才能表明组件是否被更新。\n   */\n  useEffect((): void => {\n    ref.current++;\n  }, [Math.random()]);\n  \n  return ref.current;\n};")},200:function(n,e,t){"use strict";var u=t(0);e.a=function(){var n=Object(u.useRef)(1);return Object(u.useEffect)((function(){n.current++}),[Math.random()]),n.current}},492:function(n,e,t){"use strict";t.r(e),t.d(e,"callSetStateDemo",(function(){return f})),t.d(e,"compareSetterDemo",(function(){return d})),t.d(e,"ineffectiveCallDemo",(function(){return p}));var u=t(198),a=t(93),o=t(0),r=t.n(o),s=t(94);t(133);var m=t(195),c=function(n){var e=Object(o.useRef)(n),t=e.current!==n;return e.current=n,t};var i=t(199),l=t(200),b=function(){return(b=Object.assign||function(n){for(var e,t=1,u=arguments.length;t<u;t++)for(var a in e=arguments[t])Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a]);return n}).apply(this,arguments)};var f=new a.a([new m.a("index.tsx","import React, { useState } from 'react';\nimport { Button } from 'antd';\n\nexport function CallSetStateDemo(): React.ReactElement {\n  const [num, setNum] = useState(0);\n  \n  const onClick = (): void => {\n    setNum(num + 1);\n  };\n\n  return (\n    <div>\n      <span>num</span> = {num}\n      <hr />\n      <Button onClick={onClick}>setNum(num + 1)</Button>\n    </div>\n  );\n}")],(function(){var n=Object(o.useState)(0),e=n[0],t=n[1];return r.a.createElement("div",null,r.a.createElement("span",null,"num")," = ",e,r.a.createElement("hr",null),r.a.createElement(s.a,{onClick:function(){t(e+1)}},"setNum(num + 1)"))})),d=new a.a([new m.a("index.tsx","import React, { useState } from 'react';\nimport useHasChanged from '@/demos/hooks/use-has-changed';\nimport { Button } from 'antd';\n\nexport function CompareSetterDemo(): React.ReactElement {\n  const [num, setNum] = useState(0);\n  const numHasChanged = useHasChanged(num);\n  const setNumHasChanged = useHasChanged(setNum);\n  \n  const onClick = (): void => {\n    setNum(num + 1);\n  };\n\n  return (\n    <div>\n      <span>num</span> = {num}\n      <br />\n      <span>num</span> 是否有变化: {`${numHasChanged}`}\n      <br />\n      <span>setNum</span> 是否有变化: {`${setNumHasChanged}`}\n      <hr />\n      <Button onClick={onClick}>setNum(num + 1)</Button>\n    </div>\n  );\n}"),new m.a("use-has-changed.ts",u.a),i.a],(function(){var n=Object(o.useState)(0),e=n[0],t=n[1],u=c(e),a=c(t);return r.a.createElement("div",null,r.a.createElement("span",null,"num")," = ",e,r.a.createElement("br",null),r.a.createElement("span",null,"num")," 是否有变化: ",""+u,r.a.createElement("br",null),r.a.createElement("span",null,"setNum")," 是否有变化: ",""+a,r.a.createElement("hr",null),r.a.createElement(s.a,{onClick:function(){t(e+1)}},"setNum(num + 1)"))})),p=new a.a([new m.a("index.tsx","import React, { useState } from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\nimport { Button } from 'antd';\n\nexport function IneffectiveCallDemo(): React.ReactElement {\n  const [num, setNum] = useState(0);\n  const [obj, setObj] = useState({ a: 1, b: 2 });\n  const times = useUpdateTimes();\n\n  const onNumButtonClick = (): void => {\n    setNum(num);\n  };\n\n  const onChangeNumButtonClick = (): void => {\n    setNum(num + 1);\n  };\n\n  const onObjButtonClick = (): void => {\n    obj[times] = times;\n    setObj(obj);\n  };\n\n  const onChangeObjButtonClick = (): void => {\n    obj[times] = times;\n    setObj({...obj});\n  };\n\n  const onMultiChangeNumButtonClick = (): void => {\n    setNum(num + 1);\n    setNum(num + 2);\n    setNum(num + 3);\n    setNum(num);\n  };\n\n  return (\n    <div>\n      组件更新次数：{times}\n      <hr />\n      <blockquote>\n        值类型数据测试，同理适用于 string、boolean、number、null、undefined 等。\n        <hr data-mini />\n        <span>num</span>: {num}\n        <br />\n        <Button onClick={onNumButtonClick}>\n          setNum(num)<sub>不会触发组件刷新</sub>\n        </Button>\n        <br />\n        <Button onClick={onChangeNumButtonClick}>setNum(num + 1)</Button>\n      </blockquote>\n      <hr />\n      <blockquote>\n        引用类型数据测试，同理适用于 object、function、Array、Symbo 等。\n        <hr data-mini />\n        <span>obj</span>: {JSON.stringify(obj)}\n        <br />\n        <Button onClick={onObjButtonClick}>\n          obj[times] = times &amp; setObj(obj)<sub>不会触发组件刷新</sub>\n        </Button>\n        <br />\n        <Button onClick={onChangeObjButtonClick}>obj[times] = times &amp; setObj({'{...obj}'})</Button>\n      </blockquote>\n      <hr />\n      <blockquote>\n        同一阶段，多次调用，以最后一个“新值”为准，并与“旧值”对比，如果一致，则不会触发更新。\n        <hr data-mini />\n        <span>num</span>: {num}\n        <br />\n        <Button onClick={onMultiChangeNumButtonClick}>\n          setNum(num + n) &amp; setNum(num)<sub>不会触发组件刷新</sub>\n        </Button>\n      </blockquote>\n    </div>\n  );\n}"),i.b],(function(){var n=Object(o.useState)(0),e=n[0],t=n[1],u=Object(o.useState)({a:1,b:2}),a=u[0],m=u[1],c=Object(l.a)();return r.a.createElement("div",null,"组件更新次数：",c,r.a.createElement("hr",null),r.a.createElement("blockquote",null,"值类型数据测试，同理适用于 string、boolean、number、null、undefined 等。",r.a.createElement("hr",{"data-mini":!0}),r.a.createElement("span",null,"num"),": ",e,r.a.createElement("br",null),r.a.createElement(s.a,{onClick:function(){t(e)}},"setNum(num)",r.a.createElement("sub",null,"不会触发组件刷新")),r.a.createElement("br",null),r.a.createElement(s.a,{onClick:function(){t(e+1)}},"setNum(num + 1)")),r.a.createElement("hr",null),r.a.createElement("blockquote",null,"引用类型数据测试，同理适用于 object、function、Array、Symbo 等。",r.a.createElement("hr",{"data-mini":!0}),r.a.createElement("span",null,"obj"),": ",JSON.stringify(a),r.a.createElement("br",null),r.a.createElement(s.a,{onClick:function(){a[c]=c,m(a)}},"obj[times] = times & setObj(obj)",r.a.createElement("sub",null,"不会触发组件刷新")),r.a.createElement("br",null),r.a.createElement(s.a,{onClick:function(){a[c]=c,m(b({},a))}},"obj[times] = times & setObj(","{...obj}",")")),r.a.createElement("hr",null),r.a.createElement("blockquote",null,"同一阶段，多次调用，以最后一个“新值”为准，并与“旧值”对比，如果一致，则不会触发更新。",r.a.createElement("hr",{"data-mini":!0}),r.a.createElement("span",null,"num"),": ",e,r.a.createElement("br",null),r.a.createElement(s.a,{onClick:function(){t(e+1),t(e+2),t(e+3),t(e)}},"setNum(num + n) & setNum(num)",r.a.createElement("sub",null,"不会触发组件刷新"))))}));e.default="### 描述\n`useState` 将会根据参数 `initialState` 来返回一个记忆化版本的状态值和一个更新该状态值的函数。\n\n### TsDoc 释义\n```ts\n/**\n * useState 返回一个状态值和一个更新该状态值的函数。\n * @param initialState 该状态值的初始值（该参数在代码同一位置，仅首次有效）。\n * @version 16.8.0\n */\nfunction useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n/**\n * useState 返回一个状态值和一个更新该状态值的函数。（重载 - 无参数形式）\n * @version 16.8.0\n */\nfunction useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\n```\n\n### 基础调用\n```ts\nconst [state, setState] = useState(initialState);\nconst [num, setNum] = useState(0);\nconst [str, setStr] = useState('123');\nconst [anchor, setAnchor] = useState<HTMLButtonElement>();\n```\n\n### 更新机制\n调用其 `更新函数`，可对 `状态值` 进行更新。\n```demo\nimport(callSetStateDemo);\n```\n\n### 更新函数的唯一性\n`更新函数` 具有唯一性，其自身不受更新机制而变化，所以不必将其纳入其他 `hooks` 的 `deps` 范围中。\n```demo\nimport(compareSetterDemo);\n```\n\n### 无效的调用\n`值类型` 或 `引用类型` 的状态值，只要设置的 `新值` 与 `旧值` 一致，那么便不会触发更新。\n```demo\nimport(ineffectiveCallDemo);\n```"}}]);