(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{173:function(n,e,t){"use strict";t.d(e,"a",(function(){return u}));var u=function(n,e,t){if(this.name=n,this.source=e,!t){var u=/\.([^/\\.]+?)(?=(?:[?#].*)?$)/.exec(this.name);t=u?u[1]:""}this.type=t}},182:function(n,e,t){"use strict";t.d(e,"a",(function(){return r})),t.d(e,"b",(function(){return a}));var u=t(173),r=new u.a("use-has-changed.js","import { useRef } from 'react';\n\nexport default (value) => {\n  const ref = useRef(value);\n  // 进行对比，记录对比结果\n  const result = ref.current !== value;\n\n  // 记录当前值\n  ref.current = value;\n  // 返回对比结果\n  return result;\n};"),a=new u.a("use-update-times.js","import { useRef, useEffect } from 'react';\n\nexport default () => {\n  const ref = useRef(1);\n\n  /**\n   * 不能直接使用 return ++ref.current，\n   * 因为在某些情况下，进了渲染函数，不代表组件会被更新，比如：\n   * ```js\n   * const [num, setNum] = useState(0);\n   * ...\n   * setNum(1); setNum(2); setNum(0);\n   * ```\n   * 连续的 setNum，最后 num 还是等于 0，并未变化，\n   * 这会导致进入组件的渲染函数，但其实组件不会被更新。\n   * 所以，利用 useEffect 才能表明组件是否被更新。\n   */\n  useEffect(() => {\n    ref.current++;\n  }, [Math.random()]);\n  \n  return ref.current;\n};")},400:function(n,e,t){"use strict";t.r(e),t.d(e,"interfaceDemo",(function(){return o})),t.d(e,"elementRefDemo",(function(){return l})),t.d(e,"useHasChangedDemo",(function(){return i})),t.d(e,"refVsStateDemo",(function(){return m}));var u=t(74),r=t(182),a=t(50),c=(t(75),t(0)),s=t.n(c);var f=t(173),o=new u.a([new f.a("JavaScript","/**\n * useRef 返回一个可变引用对象。\n * @param {unknown} initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n * @returns {React.MutableRefObject} 可变引用对象\n */\nfunction useRef(initialValue = undefined) {}","js"),new f.a("TypeScript","interface useRef {\n  /**\n   * useRef 返回一个可变引用对象。\n   * @param initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n   * @returns 可变引用对象。\n   */\n  <T>(initialValue: T): React.MutableRefObject<T>;\n\n  /**\n   * useRef 返回一个可变引用对象（重载 - 返回 RefObject 形式，一般适用于 ref 属性，需启用 tsconfig 的 strictNullChecks 选项）。\n   * @param initialValue 其 .current 属性的初始值（该参数在代码同一位置，仅首次有效）。\n   * @returns 可变引用对象。\n   */\n  <T>(initialValue: T | null): React.RefObject<T>;\n\n  /**\n   * useRef 返回一个可变引用对象（重载 - 无参数形式）。\n   * @returns 可变引用对象。\n   */\n  <T = undefined>(): React.MutableRefObject<T | undefined>;\n}","ts")]),l=new u.a([new f.a("index.jsx","import { Button } from 'antd';\nimport React, { useRef } from 'react';\n\nexport function ElementRefDemo() {\n  const inputRef = useRef(null);\n\n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      <p>\n        const inputRef = useRef(null);\n      </p>\n      <hr />\n      <p>\n        <input ref={inputRef} defaultValue='你好' />\n        <sub>{\"<input ref={inputRef} />\"}</sub>\n      </p>\n      <hr data-mini />\n      <p>\n        <Button onClick={focusInput}>inputRef.current.focus()</Button>\n        <sub>点击聚焦输入框</sub>\n      </p>\n    </div>\n  );\n}")],(function(){var n=Object(c.useRef)(null);return s.a.createElement("div",null,s.a.createElement("p",null,"const inputRef = useRef(null);"),s.a.createElement("hr",null),s.a.createElement("p",null,s.a.createElement("input",{ref:n,defaultValue:"你好"}),s.a.createElement("sub",null,"<input ref={inputRef} />")),s.a.createElement("hr",{"data-mini":!0}),s.a.createElement("p",null,s.a.createElement(a.a,{onClick:function(){n.current.focus()}},"inputRef.current.focus()"),s.a.createElement("sub",null,"点击聚焦输入框")))})),i=new u.a([r.a]),m=new u.a([new f.a("index.jsx","import { Button } from 'antd';\nimport React, { useRef, useState } from 'react';\n\nexport function RefVsStateDemo() {\n  const numRef = useRef(0);\n  const [num, setNum] = useState(0);\n\n  const onRefButtonClick = () => {\n    numRef.current++;\n  };\n\n  const onStateButtonClick = () => {\n    setNum(num + 1);\n  };\n\n  return (\n    <div>\n      <blockquote>\n        <h6>const numRef = useRef(0);</h6>\n        <hr data-mini />\n        <p>\n          numRef.current: {numRef.current}\n        </p>\n        <hr data-mini />\n        <p>\n          <Button onClick={onRefButtonClick}>numRef.current++</Button>\n          <sub>点击不会触发组件更新</sub>\n        </p>\n      </blockquote>\n      <hr />\n      <blockquote>\n        <h6>const [num, setNum] = useState(0);</h6>\n        <hr data-mini />\n        <p>\n          num: {num}\n        </p>\n        <hr data-mini />\n        <p>\n          <Button onClick={onStateButtonClick}>setNum({num + 1})</Button>\n          <sub>点击触发组件更新</sub>\n        </p>\n      </blockquote>\n    </div>\n  );\n}")],(function(){var n=Object(c.useRef)(0),e=Object(c.useState)(0),t=e[0],u=e[1];return s.a.createElement("div",null,s.a.createElement("blockquote",null,s.a.createElement("h6",null,"const numRef = useRef(0);"),s.a.createElement("hr",{"data-mini":!0}),s.a.createElement("p",null,"numRef.current: ",n.current),s.a.createElement("hr",{"data-mini":!0}),s.a.createElement("p",null,s.a.createElement(a.a,{onClick:function(){n.current++}},"numRef.current++"),s.a.createElement("sub",null,"点击不会触发组件更新"))),s.a.createElement("hr",null),s.a.createElement("blockquote",null,s.a.createElement("h6",null,"const [num, setNum] = useState(0);"),s.a.createElement("hr",{"data-mini":!0}),s.a.createElement("p",null,"num: ",t),s.a.createElement("hr",{"data-mini":!0}),s.a.createElement("p",null,s.a.createElement(a.a,{onClick:function(){u(t+1)}},"setNum(",t+1,")"),s.a.createElement("sub",null,"点击触发组件更新"))))}));e.default="### 描述\n`useRef` 返回一个可变引用对象，其 `.current` 属性初始化为传递的参数 - `initialValue`。返回的对象将被记忆化，在组件的整个生命周期内保持不变。值得注意的是，`useRef()` 不仅对 `ref` 属性有用，还能很方便地将任何可变值保持在对应引用的位置。\n\n### 文档释义\n```demo\nimport(interfaceDemo);\n```\n\n### 基础调用\n```jsx\nconst numRef = useRef(1);\nnumRef.current++;\n\nconst strRef = useRef('abc');\nstrRef.current += 'd';\n\nconst arrRef = useRef([]);\narrRef.current.push('你好，中国');\n\nconst divRef = useRef(null);\n<div ref={divRef} />;\n\nconst buttonRef = useRef();\n<button ref={buttonRef} />;\n```\n\n### 有效场景\n* 当需要记录一个 `值`，但不需要触发组件的更新时，可以使用 `useRef`。\n```jsx\nexport function Demo() {\n  const inputValueRef = useRef('');\n\n  const onInputChange = ({ target }) => {\n    inputValueRef.current = target.value;\n  };\n\n  const sendToServer = () => {\n    const http = new XMLHttpRequest();\n\n    http.open('get', `url?text=${inputValueRef.current}`, true);\n    http.send();\n  };\n\n  return (\n    <div>\n      <input onChange={onInputChange} />\n      <button onClick={sendToServer}>发送</button>\n    </div>\n  );\n}\n```\n\n* 将 `useRef` 使用在 `html` 元素的 `ref` 属性上，可以用于记录一个元素。\n```demo\nimport(elementRefDemo);\n```\n\n### 无效场景\n`useRef` 无法是触发组件更新的，当需要触发组件的更新时，请使用 `useState`。\n```demo\nimport(refVsStateDemo);\n```"}}]);