(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{174:function(e,n,t){"use strict";t.d(n,"a",(function(){return o})),t.d(n,"b",(function(){return c}));var a=t(0),r=t.n(a),s=t(172),o=function(e,n,t,a){void 0===n&&(n=!1),void 0===t&&(t=window);for(var r=[],s=0,o=Object.getOwnPropertyNames(t).sort();s<o.length;s++){var c=o[s],i=t[c],u=(i||{}).prototype;switch(!0){case"function"!=typeof i:case!u:case!(u instanceof e):continue}(Object.getPrototypeOf(u)===e.prototype?!n:n)&&(r.push(u),a&&a(c,u))}return r},c=function(e,n,t){void 0===n&&(n=!1);var a=[];return o(e,n,t,(function(e,n){a.push(r.a.createElement(s.Inspector,{key:e,name:e,value:n}))})),a}},420:function(e,n,t){"use strict";t.r(n),t.d(n,"watcherDemo",(function(){return p})),t.d(n,"typesDemo",(function(){return x}));var a=t(0),r=t.n(a),s=t(176),o=t(174),c=t(172),i=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var a=Array(e),r=0;for(n=0;n<t;n++)for(var s=arguments[n],o=0,c=s.length;o<c;o++,r++)a[r]=s[o];return a};var u=t(74),p=new u.a([],(function(){return r.a.createElement("div",null,r.a.createElement(c.Inspector,{name:"Rexjs.SyntaxTag",value:s.a.SyntaxTag.prototype}))})),x=new u.a([],(function(){return r.a.createElement("div",null,r.a.createElement(c.Inspector,{name:"all",value:i(Object(o.a)(s.a.SyntaxTag,!1,s.a),Object(o.a)(s.a.SyntaxTag,!0,s.a))}))}),!1,!0);n.default="### 描述\n`SyntaxTag` - `语法标签`，决定着代码匹配的内容、类型、方式以及优先级，并且是 `表达式` 与 `语句` 关联的重要媒介。\n\n### 观察\n```inline-demo\nimport(watcherDemo);\n```\n\n### 属性\n* `$class`: *number* - 标签“分类”的原始值，重写该属性，可用于标签实例化时计算 `class` 属性。\n* `$type`: *number* - 标签“类型”的原始值，重写该属性，可用于标签实例化时计算 `type` 属性。\n* `binding`: *Rexjs.SyntaxTag* - 获取绑定的标签，该标签列表一般是用于语句的 `try`、`catch` 的返回值。\n* `class`: *Rexjs.TagClass* - 标签性质定位的类别。\n* `order`: *number* - 标签排序，用于解决多个标签正则对同一段内容的匹配冲突。该属性数值越大，在标签列表中的排序越靠前、正则匹配的优先级越高。如：`===` 所对应的标签 `order` 值为 `203`，而 `==` 所对应的标签 `order` 值为 `202`，前者比后者大，所以当代码内容出现 `===` 时，是不会优先匹配 `==` 的。\n* `regexp`: *RegExp* - 标签正则，用于决定代码匹配的内容。\n* `throw`: *string* - 当解析该标签遇到无法处理的异常时，所抛出的标志，默认值 `'token'`。默认抛出形式为 `Unexpected ${tag.throw} ${content}`，如：捕获到错误的小括号 `'('`，则抛出 `Unexpected token (`。\n* `type`: *Rexjs.TagType* - 标签正则捕获类型。\n\n### 方法\n* `extractTo()`: *void* - 提取文本内容。\n* `getBoundExpression()`: *Rexjs.Expression* - 获取绑定的表达式，一般在子类使用父类逻辑，而不使用父类表达式的情况下使用。\n* `getBoundStatement()`: *Rexjs.Statement* - 获取绑定的语句，一般在子类使用父类逻辑，而不使用父类语句的情况下使用。\n* `getBoundStatements()`: *Rexjs.Statements* - 获取绑定的语句块，一般在子类使用父类逻辑，而不使用父类语句块的情况下使用。\n* `require()`: *Rexjs.SyntaxTags* - 获取此标签接下来所需匹配的标签列表。特殊说明：该方法，理应不处理任何逻辑：\n  * 组合性标签，按照组合形式得到标签列表映射。如：`class ClassName extends SuperClass {...`，这是固定组合，按照顺序得到对应标签列表即可。\n  * 非组合性标签，按照表达式衔接逻辑得到标签列表映射：“表达式标签” -> “表达式上下文标签” -> “表达式标签” -> “表达式上下文标签” -> ... -> “表达式标签”，最后以“表达式标签”结束语句；如：`a + b / c`，`a`、`b`、`c` 为“表达式标签”，`+`、`/` 为“表达式上下文标签”。\n* `visitor()`: *void* - 标签访问器，可初始化或设置表达式、语句等相关操作。这是一个重要的枢纽，用于关联上下文、表达式、语句、语句块之间的关系。\n\n### Rexjs 中的语法标签\n```inline-demo\nimport(typesDemo);\n```\n\n### 更多内容\n* [Statements](#/rexjs/statements)\n* [Statement](#/rexjs/statement)\n* [Expression](#/rexjs/expression)\n* [SyntaxTags](#/rexjs/syntax-tags)"}}]);