(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{173:function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));var a=function(n,e,t){if(this.name=n,this.source=e,!t){var a=/\.([^/\\.]+?)(?=(?:[?#].*)?$)/.exec(this.name);t=a?a[1]:""}this.type=t}},178:function(n,e,t){"use strict";var a=t(0);e.a=function(){var n=Object(a.useRef)(1);return Object(a.useEffect)((function(){n.current++}),[Math.random()]),n.current}},182:function(n,e,t){"use strict";t.d(e,"a",(function(){return l})),t.d(e,"b",(function(){return o}));var a=t(173),l=new a.a("use-has-changed.js","import { useRef } from 'react';\n\nexport default (value) => {\n  const ref = useRef(value);\n  // 进行对比，记录对比结果\n  const result = ref.current !== value;\n\n  // 记录当前值\n  ref.current = value;\n  // 返回对比结果\n  return result;\n};"),o=new a.a("use-update-times.js","import { useRef, useEffect } from 'react';\n\nexport default () => {\n  const ref = useRef(1);\n\n  /**\n   * 不能直接使用 return ++ref.current，\n   * 因为在某些情况下，进了渲染函数，不代表组件会被更新，比如：\n   * ```js\n   * const [num, setNum] = useState(0);\n   * ...\n   * setNum(1); setNum(2); setNum(0);\n   * ```\n   * 连续的 setNum，最后 num 还是等于 0，并未变化，\n   * 这会导致进入组件的渲染函数，但其实组件不会被更新。\n   * 所以，利用 useEffect 才能表明组件是否被更新。\n   */\n  useEffect(() => {\n    ref.current++;\n  }, [Math.random()]);\n  \n  return ref.current;\n};")},397:function(n,e,t){"use strict";t.r(e),t.d(e,"memoUpdateDemo",(function(){return p})),t.d(e,"interfaceDemo",(function(){return d})),t.d(e,"depsDemo",(function(){return b})),t.d(e,"inlineFuncDemo",(function(){return h})),t.d(e,"outerFuncDemo",(function(){return k})),t.d(e,"depByChildDemo",(function(){return C})),t.d(e,"undepsDemo",(function(){return f}));var a=t(0),l=t.n(a),o=t(178),s=t(50);t(75);var u=t(74),c=t(173);var m=t(182);function r(n){var e=n.method,t=Object(o.a)();return l.a.createElement("div",null,l.a.createElement("p",null,"子组件更新次数: ",l.a.createElement("span",null,t)),l.a.createElement("p",null,"method(): ",l.a.createElement("span",null,e())))}var i=l.a.memo(r);var p=new u.a([new c.a("index.jsx","import React, { useState, useCallback } from 'react';\nimport { ChildDemoWithMemo, ChildDemo } from './child';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\nimport { Button } from 'antd';\n\nexport function UpdateDemo() {\n  let getTimesInline;\n  const [date, setDate] = useState(new Date());\n  const times = useUpdateTimes();\n\n  const onButtonClick = () => {\n    setDate(\n      new Date()\n    );\n  };\n\n  const getTimes = useCallback(\n    getTimesInline = () => {\n      return times;\n    },\n    [date]\n  );\n\n  return (\n    <div>\n      <blockquote>\n        <h6>\n          const [date, setDate] = useState(new Date());\n        </h6>\n        <hr data-mini />\n        <p>\n          date: <span>{date.toString()}</span>\n        </p>\n        <p>\n          getTimesInline(): <span>{getTimesInline()}</span>\n        </p>\n        <hr data-mini />\n        <p>\n          <Button onClick={onButtonClick}>setDate(new Date())</Button>\n          <sub>点击刷新 date</sub>\n        </p>\n      </blockquote>\n      <hr />\n      <blockquote>\n        <h6>\n          <span>React.memo</span> + method\n          <sub data-sep='='>\n            <span>useCallback</span>(getTimesInline, [date])\n          </sub>\n        </h6>\n        <hr data-mini />\n        <ChildDemoWithMemo method={getTimes} />\n      </blockquote>\n      <hr />\n      <blockquote>\n        <h6>\n          <span>React.memo</span> + method\n          <sub data-sep='='>\n            <span>\n              getTimesInline\n            </span>\n          </sub>\n        </h6>\n        <hr data-mini />\n        <ChildDemoWithMemo method={getTimesInline} />\n      </blockquote>\n      <hr />\n      <blockquote>\n        <h6>\n          <del>React.memo +</del>&nbsp;method\n          <sub data-sep='='>\n            <span>useCallback</span>(getTimesInline, [date])\n          </sub>\n        </h6>\n        <hr data-mini />\n        <ChildDemo method={getTimes} />\n      </blockquote>\n      <hr />\n      <blockquote>\n        <h6>\n          <del>React.memo +</del>&nbsp;method\n          <sub data-sep='='>\n            getTimesInline\n          </sub>\n        </h6>\n        <hr data-mini />\n        <ChildDemo method={getTimesInline} />\n      </blockquote>\n    </div>\n  );\n}"),new c.a("child.jsx","import React from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\n\nexport function ChildDemo({ method }) {\n  const times = useUpdateTimes();\n\n  return (\n    <div>\n      <p>\n        子组件更新次数: <span>{times}</span>\n      </p>\n      <p>\n        method(): <span>{method()}</span>\n      </p>\n    </div>\n  );\n}\n\nexport const ChildDemoWithMemo = React.memo(ChildDemo);"),m.b],(function(){var n,e=Object(a.useState)(new Date),t=e[0],u=e[1],c=Object(o.a)(),m=Object(a.useCallback)(n=function(){return c},[t]);return l.a.createElement("div",null,l.a.createElement("blockquote",null,l.a.createElement("h6",null,"const [date, setDate] = useState(new Date());"),l.a.createElement("hr",{"data-mini":!0}),l.a.createElement("p",null,"date: ",l.a.createElement("span",null,t.toString())),l.a.createElement("p",null,"getTimesInline(): ",l.a.createElement("span",null,n())),l.a.createElement("hr",{"data-mini":!0}),l.a.createElement("p",null,l.a.createElement(s.a,{onClick:function(){u(new Date)}},"setDate(new Date())"),l.a.createElement("sub",null,"点击刷新 date"))),l.a.createElement("hr",null),l.a.createElement("blockquote",null,l.a.createElement("h6",null,l.a.createElement("span",null,"React.memo")," + method",l.a.createElement("sub",{"data-sep":"="},l.a.createElement("span",null,"useCallback"),"(getTimesInline, [date])")),l.a.createElement("hr",{"data-mini":!0}),l.a.createElement(i,{method:m})),l.a.createElement("hr",null),l.a.createElement("blockquote",null,l.a.createElement("h6",null,l.a.createElement("span",null,"React.memo")," + method",l.a.createElement("sub",{"data-sep":"="},l.a.createElement("span",null,"getTimesInline"))),l.a.createElement("hr",{"data-mini":!0}),l.a.createElement(i,{method:n})),l.a.createElement("hr",null),l.a.createElement("blockquote",null,l.a.createElement("h6",null,l.a.createElement("del",null,"React.memo +")," method",l.a.createElement("sub",{"data-sep":"="},l.a.createElement("span",null,"useCallback"),"(getTimesInline, [date])")),l.a.createElement("hr",{"data-mini":!0}),l.a.createElement(r,{method:m})),l.a.createElement("hr",null),l.a.createElement("blockquote",null,l.a.createElement("h6",null,l.a.createElement("del",null,"React.memo +")," method",l.a.createElement("sub",{"data-sep":"="},"getTimesInline")),l.a.createElement("hr",{"data-mini":!0}),l.a.createElement(r,{method:n})))}),!0),d=new u.a([new c.a("JavaScript","/**\n * useCallback 将会根据一个内联函数参数 callback 来返回一个记忆化版本的 callback；它只会在依赖项 deps 发生变化时，才会更新、改变。\n * @param {Function} callback 需要记忆化的回调函数\n * @param {unknown[]} deps 更新依赖\n * @returns {Function} 一个记忆化版本的 callback\n */\nfunction useCallback(callback, deps) {}","js"),new c.a("TypeScript","interface useCallback {\n  /**\n   * useCallback 将会根据一个内联函数参数 callback 来返回一个记忆化版本的 callback；它只会在依赖项 deps 发生变化时，才会更新、改变。\n   * @param callback 需要记忆化的回调函数\n   * @param deps 更新依赖\n   * @returns 一个记忆化版本的 callback\n   */\n  <T extends (...args: unknown[]) => unknown>(callback: T, deps: unknown[]): T;\n}","ts")]),b=new u.a([new c.a("index.jsx","import React, { useState, useCallback } from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\nimport { Button } from 'antd';\n\nexport function DepsDemo() {\n  const [changeableDeps, setChangeableDeps] = useState(true);\n  const times = useUpdateTimes();\n\n  const getTimes = useCallback(\n    () => {\n      return times;\n    },\n    // 这里得保持 deps 的个数一致，所以是 [null]\n    changeableDeps ? [times] : [null]\n  );\n\n  const onButtonClick = () => {\n    setChangeableDeps(!changeableDeps);\n  };\n\n  return (\n    <div>\n      <p>\n        getTimes = useCallback(..., [<span>{changeableDeps ? times : 'null'}</span>]);\n      </p>\n      <p>\n        getTimes():{' '}\n        <span>{getTimes()}</span>\n        <sub>{\n          changeableDeps ?\n            '每次结果都不同，说明 useCallback 在随着 deps 的变化而更新' :\n            'deps 固定为 [null]，useCallback 不会更新，结果不再变化'\n        }</sub>\n      </p>\n      <hr />\n      <p>\n        <Button onClick={onButtonClick}>\n          {changeableDeps ? '移除' : '设置'}动态 deps\n        </Button>\n      </p>\n    </div>\n  );\n}"),m.b],(function(){var n=Object(a.useState)(!0),e=n[0],t=n[1],u=Object(o.a)(),c=Object(a.useCallback)((function(){return u}),e?[u]:[null]);return l.a.createElement("div",null,l.a.createElement("p",null,"getTimes = useCallback(..., [",l.a.createElement("span",null,e?u:"null"),"]);"),l.a.createElement("p",null,"getTimes():"," ",l.a.createElement("span",null,c()),l.a.createElement("sub",null,e?"每次结果都不同，说明 useCallback 在随着 deps 的变化而更新":"deps 固定为 [null]，useCallback 不会更新，结果不再变化")),l.a.createElement("hr",null),l.a.createElement("p",null,l.a.createElement(s.a,{onClick:function(){t(!e)}},e?"移除":"设置","动态 deps")))}),!0),h=new u.a([new c.a("index.jsx","import React, { useCallback } from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\n\nexport function InlineFuncDemo() {\n  let getTimes;\n  const times = useUpdateTimes();\n\n  const getTimesWithUseCallback = useCallback(\n    // 这里每次都会生成一个新的函数，所以每次不同的 times 都会被闭包于函数内\n    getTimes = () => {\n      return times;\n    },\n    // 这里没有依赖，所以 getTimesWithUseCallback 不会变化\n    []\n  );\n\n  return (\n    <div>\n      <p>\n        <b>内联函数</b> 每秒执行结果: <span>{getTimes()}</span>\n        <sub>每次结果都不同，说明内联函数随组件刷新而重新生成</sub>\n      </p>\n      <p>\n        <b>useCallback</b> 每秒执行结果: <span>{getTimesWithUseCallback()}</span>\n        <sub>无论内联函数生成多少次，只要 deps 不发生变化，useCallback 就不会更新，所以结果永远一致</sub>\n      </p>\n    </div>\n  );\n}"),m.b],(function(){var n,e=Object(o.a)(),t=Object(a.useCallback)(n=function(){return e},[]);return l.a.createElement("div",null,l.a.createElement("p",null,l.a.createElement("b",null,"内联函数")," 每秒执行结果: ",l.a.createElement("span",null,n()),l.a.createElement("sub",null,"每次结果都不同，说明内联函数随组件刷新而重新生成")),l.a.createElement("p",null,l.a.createElement("b",null,"useCallback")," 每秒执行结果: ",l.a.createElement("span",null,t()),l.a.createElement("sub",null,"无论内联函数生成多少次，只要 deps 不发生变化，useCallback 就不会更新，所以结果永远一致")))}),!0),k=new u.a([new c.a("index.jsx","import React, { useCallback, useMemo } from 'react';\nimport { saveInput } from './locale';\n\nexport function OuterFuncDemo() {\n  // 引入外部函数，避免每次都临时创建内联函数\n  const onChange = useCallback(saveInput, []);\n\n  return (\n    <input onChange={onChange} />\n  );\n}"),new c.a("locale.js","export const saveInput = ({ target }) => {\n  const http = new XMLHttpRequest();\n\n  http.open('GET', `/a/b/c?input=${target.value}`, true);\n  http.send();\n}")]),C=new u.a([new c.a("index.jsx","import React, { useCallback } from 'react';\nimport { Child } from './child';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\n\nexport function DepByChildDemo() {\n  const times = useUpdateTimes();\n\n  // 在某些特殊情况下，需要监听子组件的注销事件，你可能会如下使用\n  const onChildUnmount = useCallback(() => {\n    console.log(`子组件在 times=${times} 时，被注销。`);\n  }, [times]);\n\n  return (\n    <div>\n      <Child onUnmount={onChildUnmount} />\n    </div>\n  );\n}"),new c.a("child.jsx","import React, { useEffect } from 'react';\n\nexport function Child({ onUnmount }) {\n  // 将 onUnmount 加入依赖，以便对最新的 onUnmount 函数进行调用\n  useEffect(() => {\n    // 当组件被注销，此函数会被调用\n    return onUnmount;\n  }, [onUnmount]);\n\n  return (\n    <div />\n  );\n}"),m.b]),f=new u.a([new c.a("index.jsx","import React, { useCallback, useState } from 'react';\nimport { Popup } from './popup';\n\nexport function UndepsDemo() {\n  const [open, setOpen] = useState(false);\n\n  // ❌ 非理想的写法\n  const onPopupClose = useCallback(() => {\n    setOpen(false);\n  }, []);\n\n  // ✅ 理想的写法\n  const onPopupClose = () => {\n    setOpen(false);\n  }\n\n  return (\n    <div>{\n      open ?\n        <Popup onClose={onPopupClose} /> :\n        null\n    }</div>\n  );\n}"),new c.a("popup.jsx","export function Popup({ onClose }) {\n  const onButtonClick = () => {\n    // ...\n    onClose();\n  }\n\n  return (\n    <div>\n      <blockquote>弹窗内容</blockquote>\n      <p>\n        <button onClick={onButtonClick}>确定</button>\n      </p>\n    </div>\n  );\n}")]);e.default="### 描述\n`useCallback` 将会根据一个内联函数参数 `callback` 来返回一个记忆化版本的 `callback`，它只会在依赖项 `deps` 发生变化时，才会更新、改变。\n\n### 文档释义\n```demo\nimport(interfaceDemo);\n```\n\n### 基础调用\n```js\nconst cb = useCallback(callback, deps);\nconst cb1 = useCallback(() => {}, []);\nconst cb2 = useCallback(() => {}, [dep1, dep2]);\n```\n\n### 更新机制\n只有当 `依赖项（deps）` 发生变化时，`useCallback` 才会更新。\n```demo\nimport(depsDemo);\n```\n注意事项：\n\n1. 函数内部所引用的 `外部变量`，多数情况下都需要加入 `deps` 中，如上例中的变量 `times`；因为是记忆化的函数，如果没有加入 `deps`，那么函数的 `变量引用`，不会随 `外部变量` 的更新而更新，直到下一次 `useCallback` 的更新；\n2. 在 `deps` 频繁更新的情况下，**不建议**使用 `useCallback`，否则依赖判断机制及函数更新会造成更多的性能消耗。\n\n### 内联函数\n\n使用 `useCallback`，其内联函数参数 `callback` 依然会随组件的每次更新而创建，这是一个 `耗性能` 的行为。\n```demo\nimport(inlineFuncDemo);\n```\n\n针对优化这个 `耗性能` 问题，可以将 `非关联上下文` 的内联函数，提取到 `组件外部` 或 `其他文件` 中，这样不仅能优化性能，还能将部分逻辑代码分离，使代码更简单、整洁。\n```demo\nimport(outerFuncDemo);\n```\n\n### 有效场景\n* `useCallback` 函数被子组件 `deps` 所依赖，即子组件需根据该函数的更新，从而进行某些特定操作。\n```demo\nimport(depByChildDemo);\n```\n\n* 配合 `React.memo` 使用，以避免子组件随父组件的频繁刷新；类似 `React.Component` 的 `shouldComponentUpdate` 机制。\n```demo\nimport(memoUpdateDemo);\n```\n\n### 无效场景\n当函数不需要加入到任何其他 `hooks` 的 `deps` 中，也没有配合 `React.memo` 使用的话，不需要使用 `useCallback` - 因为没有使用到函数记忆化的需求，反而会造成额外的性能消耗，如：\n\n* \b直接使用在 `HTMLElement` 的事件上；\n```jsx\nexport function Demo({ text }) {\n  // ❌ 非理想的写法\n  const onButtonClick = useCallback(() => {\n    console.log(text);\n  }, [text]);\n\n  // ✅ 理想的写法\n  const onButtonClick = () => {\n    console.log(text);\n  };\n\n  return (\n    <button onClick={onButtonClick}>点击</button>\n  );\n}\n```\n\n* 在其他内联函数中直接调用该函数；\n```jsx\nexport function Demo() {\n  // ❌ 非理想的写法\n  const callServer = useCallback(() => {\n    // ...\n  }, []);\n\n  // ✅ 理想的写法\n  const callServer = () => {\n    // ...\n  };\n\n  const onButtonClick = () => {\n    // ...\n    callServer();\n    // ...\n  };\n\n  return (\n    <button onClick={onButtonClick}>点击</button>\n  );\n}\n```\n\n* 直接使用在自定义或第三方组件的非依赖性回调函数上；\n```demo\nimport(undepsDemo);\n```\n\n* 等等"}}]);