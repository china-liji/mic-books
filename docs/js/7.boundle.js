(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{173:function(n,e,t){"use strict";t.d(e,"a",(function(){return s}));var s=function(n,e,t){if(this.name=n,this.source=e,!t){var s=/\.([^/\\.]+?)(?=(?:[?#].*)?$)/.exec(this.name);t=s?s[1]:""}this.type=t}},178:function(n,e,t){"use strict";var s=t(0);e.a=function(){var n=Object(s.useRef)(1);return Object(s.useEffect)((function(){n.current++}),[Math.random()]),n.current}},182:function(n,e,t){"use strict";t.d(e,"a",(function(){return a})),t.d(e,"b",(function(){return u}));var s=t(173),a=new s.a("use-has-changed.js","import { useRef } from 'react';\n\nexport default (value) => {\n  const ref = useRef(value);\n  // 进行对比，记录对比结果\n  const result = ref.current !== value;\n\n  // 记录当前值\n  ref.current = value;\n  // 返回对比结果\n  return result;\n};"),u=new s.a("use-update-times.js","import { useRef, useEffect } from 'react';\n\nexport default () => {\n  const ref = useRef(1);\n\n  /**\n   * 不能直接使用 return ++ref.current，\n   * 因为在某些情况下，进了渲染函数，不代表组件会被更新，比如：\n   * ```js\n   * const [num, setNum] = useState(0);\n   * ...\n   * setNum(1); setNum(2); setNum(0);\n   * ```\n   * 连续的 setNum，最后 num 还是等于 0，并未变化，\n   * 这会导致进入组件的渲染函数，但其实组件不会被更新。\n   * 所以，利用 useEffect 才能表明组件是否被更新。\n   */\n  useEffect(() => {\n    ref.current++;\n  }, [Math.random()]);\n  \n  return ref.current;\n};")},401:function(n,e,t){"use strict";t.r(e),t.d(e,"interfaceDemo",(function(){return i})),t.d(e,"useHasChangedDemo",(function(){return l})),t.d(e,"depsDemo",(function(){return f})),t.d(e,"uncontextDemo",(function(){return p}));var s=t(74),a=t(182),u=t(173),r=t(0),o=t.n(r),c=t(178),m=t(50);t(75);var i=new s.a([new u.a("JavaScript","/**\n * useMemo 会根据计算函数 factory 的执行结果，返回一个记忆化的计算值。它只会在依赖项 deps 发生变化时，才会重新计算。\n * @param {Function} factory 计算函数\n * @param {unknown[]} deps 更新依赖\n * @returns {any} 一个记忆化的计算值\n */\nfunction useMemo(factory, deps) {}","js"),new u.a("TypeScript","interface useMemo {\n  /**\n   * useMemo 会根据计算函数 factory 的执行结果，返回一个记忆化的计算值。它只会在依赖项 deps 发生变化时，才会重新计算。\n   * @param factory 计算函数\n   * @param deps 更新依赖\n   * @returns 一个记忆化的计算值\n   */\n  <T>(factory: () => T, deps: unknown[] | undefined): T;\n}","ts")]),l=new s.a([a.a]),f=new s.a([new u.a("index.jsx","import React, { useState, useMemo } from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\nimport { Button } from 'antd';\n\nexport function DepsDemo() {\n  const [changeableDeps, setChangeableDeps] = useState(true);\n  const times = useUpdateTimes();\n\n  const ticks = useMemo(\n    () => {\n      return Date.now();\n    },\n    // 这里得保持 deps 的个数一致，所以是 [null]\n    changeableDeps ? [times] : [null]\n  );\n\n  const onButtonClick = () => {\n    setChangeableDeps(!changeableDeps);\n  };\n\n  return (\n    <div>\n      <p>\n        const ticks = useMemo(..., [<span>{changeableDeps ? times : 'null'}</span>]);\n      </p>\n      <hr data-mini />\n      <p>\n        组件更新次数：<span>{times}</span>\n      </p>\n      <p>\n        ticks:{' '}\n        <span>{ticks}</span>\n        <sub>{\n          changeableDeps ?\n            '每次结果都不同，说明 useMemo 的计算值在随着 deps 的变化而更新' :\n            'deps 固定为 [null]，useMemo 不会更新，结果不再变化'\n        }</sub>\n      </p>\n      <hr data-mini />\n      <p>\n        <Button onClick={onButtonClick}>\n          {changeableDeps ? '移除' : '设置'}动态 deps\n        </Button>\n      </p>\n    </div>\n  );\n}"),a.b],(function(){var n=Object(r.useState)(!0),e=n[0],t=n[1],s=Object(c.a)(),a=Object(r.useMemo)((function(){return Date.now()}),e?[s]:[null]);return o.a.createElement("div",null,o.a.createElement("p",null,"const ticks = useMemo(..., [",o.a.createElement("span",null,e?s:"null"),"]);"),o.a.createElement("hr",{"data-mini":!0}),o.a.createElement("p",null,"组件更新次数：",o.a.createElement("span",null,s)),o.a.createElement("p",null,"ticks:"," ",o.a.createElement("span",null,a),o.a.createElement("sub",null,e?"每次结果都不同，说明 useMemo 的计算值在随着 deps 的变化而更新":"deps 固定为 [null]，useMemo 不会更新，结果不再变化")),o.a.createElement("hr",{"data-mini":!0}),o.a.createElement("p",null,o.a.createElement(m.a,{onClick:function(){t(!e)}},e?"移除":"设置","动态 deps")))}),!0),p=new s.a([new u.a("index.jsx","import { Tooltip } from 'antd';\nimport React, { useMemo } from 'react';\nimport { alignType } from './locale';\n\nexport function UncontextDemo() {\n  let align;\n\n  // ❌ 非理想的写法\n  align = useMemo(() => {\n    return {\n      offset: [5, 5],\n      targetOffset: [10, 10],\n    };\n  }, []);\n\n  // ✅ 理想的写法\n  align = alignType;\n\n  return (\n    <Tooltip align={align} />\n  );\n}"),new u.a("locale.js","export const alignType = {\n  offset: [5, 5],\n  targetOffset: [10, 10],\n};")]);e.default="### 描述\n`useMemo` 会根据计算函数 `factory` 的执行结果，返回一个记忆化的计算值。它只会在依赖项 `deps` 发生变化时，才会重新计算。  \n\n> \n* `useMemo` 具有记忆化 - 当 `deps` 不发生变化时，无论计算函数所关联的上下文变量如何变化，其计算值都不会发生改变。\n* `useMemo` 可避免额外的性能消耗 - 当 `deps` 不发生变化时，无论组件如何频繁刷新，都不会调用其计算函数，以规避许多重复的计算消耗。\n\n### 文档释义\n```demo\nimport(interfaceDemo);\n```\n\n### 基础调用\n```js\nconst refreshKey = useMemo(factory, deps);\n\nconst refreshKey1 = useMemo(() => {\n  return Date.now();\n}, []);\n\nconst refreshKey2 = useMemo(() => {\n  return Date.now();\n}, [dep1, dep2]);\n```\n\n### 更新机制\n只有当 `依赖项（deps）` 发生变化时，`useMemo` 才会更新。\n```demo\nimport(depsDemo);\n```\n注意事项：\n\n1. 计算函数内部所引用的 `外部变量`，多数情况下都需要加入 `deps` 中，如上例中的变量 `times`。\n2. 在 `deps` 频繁更新的情况下，**不建议**使用 `useMemo`，否则依赖判断机制将会造成更多的性能消耗。\n\n### 有效场景\n* 依赖的计算 - 当计算值需要根据某些变量的改变而重新计算时，理应将其计算逻辑放入 `useMemo` 的计算函数之中，并将那些会变化的变量，作为 `useMemo` 的 `deps` 参数传入。\n\n```js\nexport function Demo({ dataList }) {\n  const count = useMemo(() => {\n    let count = 0;\n\n    for (const { value } of dataList) {\n      count += value;\n    }\n\n    return count;\n  }, [dataList]);\n}\n```\n\n* 复杂的计算 - 当伴有复杂的计算时，不管是否有 `deps`，都理应将其计算逻辑放入 `useMemo` 的计算函数之中，以减少组件渲染时不必要的额外消耗。\n\n```js\nexport function Demo({ defaultText }) {\n  // defaultText 只在初始化时使用一次，所以不需要放入 deps\n  const defaultTextWidth = useMemo(() => {\n    return document.createElement('canvas').getContext('2d').measureText(defaultText).width;\n  }, []);\n}\n```\n\n### 无效场景\n由于计算函数 `factory` 的创建与依赖 `deps` 的判断机制，都会产生一定的性能消耗。所以在以下情况，应避免使用 `useMemo`：\n\n* 无关上下文的固定计算 - 没有上下文依赖且始终返回固定值，这种情况下不需要使用 `useMemo`。\n```demo\nimport(uncontextDemo);\n```\n\n* 简单的计算 - 当计算十分简单时，耗能可能比计算函数的创建还低时，这种情况下不需要使用 `useMemo`。\n```js\nfunction Demo({ text, before = '\"', after = before}) {\n  let fullText;\n\n  // ❌ 非理想的写法\n  fullText = useMemo(() => {\n    return 'full text:' + before + text + after;\n  }, [text, before, after]);\n\n  // ✅ 理想的写法\n  fullText = 'full text:' + before + text + after;\n}\n```\n\n* 频繁更新的 `deps` - 当 `deps` 频繁更新，相当于组件的每次渲染都会重新计算，这种情况下不需要使用 `useMemo`。\n```js\n// 如果未提供 time，每次渲染都会获取当前时间\nfunction Demo({ time = Date.now() }) {\n  let year;\n\n  // ❌ 非理想的写法\n  year = useMemo(() => {\n    return new Date(time).getFullYear();\n  }, [time]);\n\n  // ✅ 理想的写法\n  year = new Date(time).getFullYear();\n}\n```"}}]);