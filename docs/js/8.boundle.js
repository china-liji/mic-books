(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{173:function(n,e,t){"use strict";t.d(e,"a",(function(){return u}));var u=function(n,e,t){if(this.name=n,this.source=e,!t){var u=/\.([^/\\.]+?)(?=(?:[?#].*)?$)/.exec(this.name);t=u?u[1]:""}this.type=t}},178:function(n,e,t){"use strict";var u=t(0);e.a=function(){var n=Object(u.useRef)(1);return Object(u.useEffect)((function(){n.current++}),[Math.random()]),n.current}},182:function(n,e,t){"use strict";t.d(e,"a",(function(){return a})),t.d(e,"b",(function(){return s}));var u=t(173),a=new u.a("use-has-changed.js","import { useRef } from 'react';\n\nexport default (value) => {\n  const ref = useRef(value);\n  // 进行对比，记录对比结果\n  const result = ref.current !== value;\n\n  // 记录当前值\n  ref.current = value;\n  // 返回对比结果\n  return result;\n};"),s=new u.a("use-update-times.js","import { useRef, useEffect } from 'react';\n\nexport default () => {\n  const ref = useRef(1);\n\n  /**\n   * 不能直接使用 return ++ref.current，\n   * 因为在某些情况下，进了渲染函数，不代表组件会被更新，比如：\n   * ```js\n   * const [num, setNum] = useState(0);\n   * ...\n   * setNum(1); setNum(2); setNum(0);\n   * ```\n   * 连续的 setNum，最后 num 还是等于 0，并未变化，\n   * 这会导致进入组件的渲染函数，但其实组件不会被更新。\n   * 所以，利用 useEffect 才能表明组件是否被更新。\n   */\n  useEffect(() => {\n    ref.current++;\n  }, [Math.random()]);\n  \n  return ref.current;\n};")},398:function(n,e,t){"use strict";t.r(e),t.d(e,"interfaceDemo",(function(){return p})),t.d(e,"updateDemo",(function(){return d})),t.d(e,"uniqueSetterDemo",(function(){return f})),t.d(e,"valueTypeDemo",(function(){return h})),t.d(e,"refTypeDemo",(function(){return S})),t.d(e,"lastValueDemo",(function(){return E})),t.d(e,"triggerUpdateDemo",(function(){return b}));var u=t(74),a=t(0),s=t.n(a),r=t(178),o=t(50);t(75);var m=function(){return(m=Object.assign||function(n){for(var e,t=1,u=arguments.length;t<u;t++)for(var a in e=arguments[t])Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a]);return n}).apply(this,arguments)};var l=t(173),c=function(n){var e=Object(a.useRef)(n),t=e.current!==n;return e.current=n,t};var i=t(182);var p=new u.a([new l.a("JavaScript","/**\n * useState 将会根据参数 initialState 来返回一个记忆化版本的状态值和一个更新该状态值的函数。\n * @param {unknown} initialState 该状态值的初始值（该参数在代码同一位置，仅首次有效）。\n * @returns {[unknown, Function]} 一个状态值和一个更新该状态值的函数\n */\nfunction useState(initialState = undefined) {}","js"),new l.a("TypeScript","interface useState {\n  /**\n   * useState 将会根据参数 initialState 来返回一个记忆化版本的状态值和一个更新该状态值的函数。\n   * @param initialState 该状态值的初始值（该参数在代码同一位置，仅首次有效）。\n   * @returns 一个状态值和一个更新该状态值的函数\n   */\n  <S>(initialState: S | (() => S)): [S, React.Dispatch<React.SetStateAction<S>>];\n\n  /**\n   * useState 将会根据参数 initialState 来返回一个记忆化版本的状态值和一个更新该状态值的函数。\n   * @returns 一个状态值和一个更新该状态值的函数\n   */\n  <S = undefined>(): [S | undefined, React.Dispatch<React.SetStateAction<S | undefined>>];\n}","ts")]),d=new u.a([new l.a("index.jsx","import React, { useState } from 'react';\nimport { Button } from 'antd';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\n\nexport function UpdateDemo() {\n  const times = useUpdateTimes();\n  const [num, setNum] = useState(times);\n  \n  const onClick = () => {\n    setNum(num + 1);\n  };\n\n  return (\n    <div>\n      <p>\n        const [num, setNum] = useState(<span>{times}</span>);\n      </p>\n      <hr data-mini />\n      <p>\n        num: <span>{num}</span>\n        <sub>该状态值随更新函数 setNum 的调用而更新，并不随 useState 的参数改变</sub>\n      </p>\n      <hr />\n      <p>\n        <Button onClick={onClick}>setNum(num + 1)</Button>\n      </p>\n    </div>\n  );\n}"),i.b],(function(){var n=Object(r.a)(),e=Object(a.useState)(n),t=e[0],u=e[1];return s.a.createElement("div",null,s.a.createElement("p",null,"const [num, setNum] = useState(",s.a.createElement("span",null,n),");"),s.a.createElement("hr",{"data-mini":!0}),s.a.createElement("p",null,"num: ",s.a.createElement("span",null,t),s.a.createElement("sub",null,"该状态值随更新函数 setNum 的调用而更新，并不随 useState 的参数改变")),s.a.createElement("hr",null),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){u(t+1)}},"setNum(num + 1)")))}),!0),f=new u.a([new l.a("index.jsx","import React, { useState } from 'react';\nimport useHasChanged from '@/demos/hooks/use-has-changed';\nimport { Button } from 'antd';\n\nexport function UniqueSetterDemo() {\n  const [num, setNum] = useState(0);\n  const numHasChanged = useHasChanged(num);\n  const setNumHasChanged = useHasChanged(setNum);\n  \n  const onClick = () => {\n    setNum(num + 1);\n  };\n\n  return (\n    <div>\n      <p>\n        const [num, setNum] = useState(0);\n      </p>\n      <hr />\n      <p>\n        num: <span>{num}</span>\n      </p>\n      <p>\n        num 是否有变化: <span>{`${numHasChanged}`}</span>\n      </p>\n      <p>\n        setNum 是否有变化: <span>{`${setNumHasChanged}`}</span>\n      </p>\n      <hr />\n      <p>\n        <Button onClick={onClick}>setNum(num + 1)</Button>\n      </p>\n    </div>\n  );\n}"),i.a],(function(){var n=Object(a.useState)(0),e=n[0],t=n[1],u=c(e),r=c(t);return s.a.createElement("div",null,s.a.createElement("p",null,"const [num, setNum] = useState(0);"),s.a.createElement("hr",null),s.a.createElement("p",null,"num: ",s.a.createElement("span",null,e)),s.a.createElement("p",null,"num 是否有变化: ",s.a.createElement("span",null,""+u)),s.a.createElement("p",null,"setNum 是否有变化: ",s.a.createElement("span",null,""+r)),s.a.createElement("hr",null),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){t(e+1)}},"setNum(num + 1)")))})),h=new u.a([new l.a("index.jsx","import React, { useState } from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\nimport { Button } from 'antd';\n\nexport function ValueTypeDemo() {\n  const [num, setNum] = useState(1024);\n  const times = useUpdateTimes();\n\n  const onNumButtonClick = () => {\n    setNum(num);\n  };\n\n  const onChangeNumButtonClick = () => {\n    setNum(num + 1);\n  };\n\n  return (\n    <div>\n      <p>\n        const [num, setNum] = useState(1024);\n      </p>\n      <hr />\n      <p>\n        组件更新次数：<span>{times}</span>\n      </p>\n      <p>\n        num: <span>{num}</span>\n      </p>\n      <hr />\n      <p>\n        <Button onClick={onNumButtonClick}>setNum(num);</Button>\n        <sub>不会触发组件刷新</sub>\n      </p>\n      <p>\n        <Button onClick={onChangeNumButtonClick}>setNum(num + 1);</Button>\n      </p>\n    </div>\n  );\n}"),i.b],(function(){var n=Object(a.useState)(1024),e=n[0],t=n[1],u=Object(r.a)();return s.a.createElement("div",null,s.a.createElement("p",null,"const [num, setNum] = useState(1024);"),s.a.createElement("hr",null),s.a.createElement("p",null,"组件更新次数：",s.a.createElement("span",null,u)),s.a.createElement("p",null,"num: ",s.a.createElement("span",null,e)),s.a.createElement("hr",null),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){t(e)}},"setNum(num);"),s.a.createElement("sub",null,"不会触发组件刷新")),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){t(e+1)}},"setNum(num + 1);")))})),S=new u.a([new l.a("index.jsx","import React, { useState } from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\nimport { Button } from 'antd';\n\nexport function RefTypeDemo() {\n  const [obj, setObj] = useState({});\n  const times = useUpdateTimes();\n\n  const onObjButtonClick = () => {\n    obj[times] = true;\n    setObj(obj);\n  };\n\n  const onChangeObjButtonClick = () => {\n    obj[times] = true;\n    setObj({...obj});\n  };\n\n  return (\n    <div>\n      <p>\n        const [obj, setObj] = useState({'{}'});  \n      </p>\n      <hr />\n      <p>\n        组件更新次数：<span>{times}</span>\n      </p>\n      <p>\n        obj: <span>{JSON.stringify(obj)}</span>\n      </p>\n      <hr />\n      <p>\n        <Button onClick={onObjButtonClick}>\n          obj[{times}] = true, setObj(obj);\n        </Button>\n        <sub>不会触发组件刷新</sub>\n      </p>\n      <p>\n        <Button onClick={onChangeObjButtonClick}>obj[{times}] = true, setObj({'{...obj}'});</Button>\n      </p>\n    </div>\n  );\n}"),i.b],(function(){var n=Object(a.useState)({}),e=n[0],t=n[1],u=Object(r.a)();return s.a.createElement("div",null,s.a.createElement("p",null,"const [obj, setObj] = useState(","{}",");"),s.a.createElement("hr",null),s.a.createElement("p",null,"组件更新次数：",s.a.createElement("span",null,u)),s.a.createElement("p",null,"obj: ",s.a.createElement("span",null,JSON.stringify(e))),s.a.createElement("hr",null),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){e[u]=!0,t(e)}},"obj[",u,"] = true, setObj(obj);"),s.a.createElement("sub",null,"不会触发组件刷新")),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){e[u]=!0,t(m({},e))}},"obj[",u,"] = true, setObj(","{...obj}",");")))})),E=new u.a([new l.a("index.jsx","import React, { useState } from 'react';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\nimport { Button } from 'antd';\n\nexport function LastValueDemo() {\n  const [num, setNum] = useState(1024);\n  const times = useUpdateTimes();\n\n  const onMultiChangeNumButtonClick = () => {\n    setNum(num + 1);\n    setNum(num + 2);\n    setNum(num + 3);\n    setNum(num);\n  };\n\n  const onChangeNumButtonClick = () => {\n    setNum(num + 1);\n    setNum(num + 2);\n    setNum(num + 3);\n  };\n\n  return (\n    <div>\n      <p>\n        const [num, setNum] = useState(1024);\n      </p>\n      <hr />\n      <p>\n        组件更新次数：<span>{times}</span>\n      </p>\n      <p>\n        num: <span>{num}</span>\n      </p>\n      <hr />\n      <p>\n        <Button onClick={onMultiChangeNumButtonClick}>\n          setNum(num + n), setNum(num);\n        </Button>\n        <sub>不会触发组件刷新</sub>\n      </p>\n      <p>\n        <Button onClick={onChangeNumButtonClick}>\n          setNum(num + 1), setNum(num + 2), setNum(num + 3);\n        </Button>\n      </p>\n    </div>\n  );\n}"),i.b],(function(){var n=Object(a.useState)(1024),e=n[0],t=n[1],u=Object(r.a)();return s.a.createElement("div",null,s.a.createElement("p",null,"const [num, setNum] = useState(1024);"),s.a.createElement("hr",null),s.a.createElement("p",null,"组件更新次数：",s.a.createElement("span",null,u)),s.a.createElement("p",null,"num: ",s.a.createElement("span",null,e)),s.a.createElement("hr",null),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){t(e+1),t(e+2),t(e+3),t(e)}},"setNum(num + n), setNum(num);"),s.a.createElement("sub",null,"不会触发组件刷新")),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){t(e+1),t(e+2),t(e+3)}},"setNum(num + 1), setNum(num + 2), setNum(num + 3);")))})),b=new u.a([new l.a("index.jsx","import React, { useState } from 'react';\nimport { Button } from 'antd';\nimport useUpdateTimes from '@/demos/hooks/use-update-times';\n\nexport function TriggerUpdateDemo() {\n  const times = useUpdateTimes();\n  const [hidden, setHidden] = useState(false);\n  \n  const onClick = () => {\n    setHidden(!hidden);\n  };\n\n  return (\n    <div>\n      <p>\n        const [hidden, setHidden] = useState(false);  \n      </p>\n      <hr />\n      <p>\n        组件更新次数：<span>{times}</span>\n      </p>\n      <blockquote>\n        hidden: <span>{`${hidden}`}</span>\n        <p hidden={hidden} style={{ width: 200, height: 100, padding: 5, backgroundColor: 'gold', opacity: 0.6 }}>\n          可隐藏的区域\n        </p>\n      </blockquote>\n      <hr />\n      <p>\n        <Button onClick={onClick}>\n          setHidden({`${!hidden}`})\n        </Button>\n        <sub>点击变更状态，并更新组件</sub>\n      </p>\n    </div>\n  );\n}"),i.b],(function(){var n=Object(r.a)(),e=Object(a.useState)(!1),t=e[0],u=e[1];return s.a.createElement("div",null,s.a.createElement("p",null,"const [hidden, setHidden] = useState(false);"),s.a.createElement("hr",null),s.a.createElement("p",null,"组件更新次数：",s.a.createElement("span",null,n)),s.a.createElement("blockquote",null,"hidden: ",s.a.createElement("span",null,""+t),s.a.createElement("p",{hidden:t,style:{width:200,height:100,padding:5,backgroundColor:"gold",opacity:.6}},"可隐藏的区域")),s.a.createElement("hr",null),s.a.createElement("p",null,s.a.createElement(o.a,{onClick:function(){u(!t)}},"setHidden(",""+!t,")"),s.a.createElement("sub",null,"点击变更状态，并更新组件")))}));e.default="### 描述\n`useState` 将会根据参数 `initialState` 来返回一个记忆化版本的状态值和一个更新该状态值的函数。\n\n### 文档释义\n```demo\nimport(interfaceDemo);\n```\n\n### 基础调用\n```js\nconst [state, setState] = useState(initialState);\nconst [num, setNum] = useState(0);\nconst [str, setStr] = useState('123');\nconst [anchor, setAnchor] = useState<HTMLButtonElement>();\n```\n\n### 更新机制\n`状态值` 的初始值决定于 `useState` 的参数，其后无论 `useState` 的参数为任何值，都不会改变当前的 `状态值`，除非调用 `更新函数`，才可对 `状态值` 进行更新。\n```demo\nimport(updateDemo);\n```\n\n### 更新函数的唯一性\n`更新函数` 具有唯一性，其自身不受更新机制而变化，所以不必将其纳入其他 `hooks` 的 `deps` 范围中。\n```demo\nimport(uniqueSetterDemo);\n```\n\n### 有效场景\n当需要记录或改变 `状态值`，以触发组件的更新时，可以使用 `useState`。\n```demo\nimport(triggerUpdateDemo);\n```\n\n### 无效场景\n`useState` 的目的是修改状态以触发组件的更新，如果组件不需要更新或者无法导致组件的更新，都属于无效的调用，一般有以下几种情形：\n\n* 当只需要记录或改变一个 `值`，却不需要更新组件时，使用 `useRef` 以代替 `useState`。\n```jsx\nfunction Demo() {\n  // ❌ 非理想的写法\n  const [inputValue, setInputValue] = useState('');\n  // ✅ 理想的写法\n  const inputValueRef = useRef('');\n\n  const onInputChange = ({ target }) => {\n    // ❌ 非理想的写法\n    setInputValue(target.value);\n\n    // ✅ 理想的写法\n    inputValueRef.current = target.value;\n  };\n\n  const sendToServer = () => {\n    const http = new XMLHttpRequest();\n\n    http.open('get', `url?text=${inputValueRef.current}`, true);\n    http.send();\n  };\n\n  return (\n    <div>\n      <input onChange={onInputChange} />\n      <button onClick={sendToServer}>发送</button>\n    </div>\n  );\n}\n```\n\n* `值类型` 的 `状态值`，当设置的 `新值` 与 `旧值` 一致时，则无法触发组件的更新，属于无效调用。\n```demo\nimport(valueTypeDemo);\n```\n\n* `引用类型` 的 `状态值`，当设置新值时，如果只修改了 `引用对象` 的属性，而并没有改变 `对象的引用`（没有设置新的对象），也是无法触发组件的更新，属于无效调用。\n```demo\nimport(refTypeDemo);\n```\n\n* 同一阶段，多次调用，以最后一个 `新值` 为准，并与 `旧值` 对比，如果一致，还是无法触发组件的更新，属于无效调用。\n```demo\nimport(lastValueDemo);\n```"}}]);